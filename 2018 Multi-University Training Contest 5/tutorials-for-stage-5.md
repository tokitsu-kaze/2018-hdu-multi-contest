命题人在赛前预估的难度等级是：

- 非常简单：B, E
- 简单：C, G, H
- 中等：A, F, I, K
- 困难：D, J, L

而正确通过每道题目的队伍数量如下：

| 题目     | A |    B |  C |  D |    E |  F |   G |  H | I |  J | K |  L |
|:----|----:|----:|----:|----:|----:|----:|----:|----:|----:|----:|----:|----:|
| 通过数量 |  7 |  457 |  2 |  10 |  906 |  3 |  193 |  44 | 2 |  3 |  1 |  0 |
| 提交数量 | 29 | 4513 | 32 | 163 | 3444 | 36 | 1720 | 234 | 7 | 88 | 10 | 25 |

可以看到预测结果与实际结果的差距还是很大的，不得不承认这场比赛有点难了。不论如何，我们祝愿大家能在未来的比赛中获得更好的经验和更好的奖项。

# A. Always Online

*Shortest judge solution: 2670 bytes.*

借助反证法，我们可以证明，对于一个连通无向图，每条边在至多一个环中当且仅当任意两点间的不相交路径至多两条。另外，最大流和最小割是等价问题，我们只需要考虑割掉最少容量的边使得源点 $s$ 与汇点 $t$ 不连通即可。

考虑 $s$-$t$ 割问题，如果一个环中割掉了至少两条边，则通过调整法可以只割掉至多两条边，因为 $s$ 到 $t$ 至多有两条不相交路径经过这个环。此外，如果多个环都被割掉了一些边，则通过反证法和调整法可以知道只割掉至多一个环的边。

一个观察是，如果在最小割中一个环被割掉了至少一条边，那么一定是割掉了两条边，且其中一条是容量最小的边。因此，我们可以将每个环中容量最小的边移除，给这个环中其他边加上它的容量，使得任意两点间的最大流量在数值上不发生变化。

经过改动的图形成了一棵树。我们只需要向空图中按容量降序加入每条边，便可以知道对于加入容量 $w$ 的边后才连通的两个点集 $S$ 和 $T$ 有 $\mathrm{flow}(s, t) = w$ $(s \in S, t \in T)$。利用并查集维护这些点集，同时统计每个点集里有多少个点的某个二进制位是 $1$ 即可按位计算答案。时间复杂度 $\mathcal{O}(m \log n)$。

注意 $\mathrm{flow}(s, t)$ 可以达到 $2 \cdot 10^9$，这意味着答案可能超过 $2^{63}$。

# B. Beautiful Now

*Shortest judge solution: 1584 bytes.*

考虑下标的置换，可以发现最少的交换次数等于 $n$ 减去置换中循环的数量，所以可以枚举所有的 $n$ 排列解决此题。对于每个置换，只需要检查它是否可以在 $k$ 次交换内实现（因为可以交换相同的位置）并更新答案。期望时间复杂度是 $\mathcal{O}(n!)$，$\mathcal{O}(n! n)$ 的算法有可能会超时（也可能不超时）。为了实现期望复杂度可能需要在搜索和回溯过程中高效维护链和环的信息。

# C. Call It What You Want

*Shortest judge solution: 2019 bytes.*

显然，除了 $n = 1$ 之外，其他情况下 $\Phi_n(x)$ 的常数项总是 $1$。此外，泰勒展开表明，如果 $f(x)$ 是一个常数项为零的整系数多项式，那么 $\ln\left(1 + f(x)\right)$ 是一个整系数形式幂级数。因此，简单运用 M?bius 反演可知

$$\ln\left(1 - x^n\right) = \ln\left(\prod_{d | n}{\left((-1)^{[n = 1]} \Phi_d(x)\right)}\right) \Leftrightarrow \ln\left((-1)^{[n = 1]} \Phi_n(x)\right) = \ln\left(\prod_{d | n}{\left(1 - x^d\right)^{\mu(n / d)}}\right)$$

不难发现，$\Phi_d(x)$ 的最高项次数是 $\varphi(d)$。但更重要的是注意到每个多项式 $(1 - x^d)$ 只有两项非零。因此直接在模 $x^{\varphi(d) + 1}$ 意义下计算类似背包动态规划形式的卷积即可做到时间复杂度 $\mathcal{O}(\sum_{d | n}{2^{\omega(d)}\varphi(d)}) = \mathcal{O}(2^6 n)$，因为 $2 \times 3 \times 5 \times 7 \times 11 \times 13 = 30030$ 而 $30030 \times 17 = 510510 \geq n$。

这个题是思考卷积优化时想出来的，不过，我们尽可能卡掉了大部分用了加速卷积方法的做法，放过了一些类似暴力的做法。

P.S. 可能要小心负系数的处理。

# D. Daylight

*Shortest judge solution: 4518 bytes.*

考虑分别到 $u$ 和 $v$ 距离不超过 $w$ 的点集 $S_u$ 和 $S_v$，令 $u$ 到 $v$ 的距离是 $k$，则 $S_u$ 和 $S_v$ 的交集是到 $u$ 到 $v$ 这条路径中点距离超过 $w - \frac{k}{2}$ 的点集。不妨把树上的每条边的中点视为一个新点，则问题转化为在线询问到一个点距离不超过定值的点数。

如果一个点作为树根时它最大的子树节点数达到最少，那么定义这个点是树的重心。尝试将树进行分治，每次选择树的重心作为树根，处理所有必经重心的路径，再递归处理删掉当前重心后的每个连通块，这样每一层至多需要 $\mathcal{O}(n)$ 的空间记录每个连通块中距离相应重心不超过定值的有效点数，而这样的层数不超过 $\left \lceil \log_2(n + 1) \right \rceil$。

实际上，增加 $(n - 1)$ 个新点是不必要的，只需要在处理询问时讨论从边的中点走到连通块的重心时先经过这条边的哪个端点即可。时间复杂度 $\mathcal{O}(n \log n)$。

# E. Everything Has Changed

*Shortest judge solution: 709 bytes. Shortest judge Java solution: 771 bytes.*

注意切割区域两两不相交，则不同切割区域不会相互影响。枚举每个与圆盘相交的切割区域，计算互相被包含的圆周长度即可。

# F. Fireflies

*Shortest judge solution: 2222 bytes.*

Dilworth 定理表明，最小链覆盖数等于最大反链数，也即选出互不可达位置的最多数目。Sperner 定理显示，若要选择 $S$ 的幂集的一个子集使得其中没有一个集合包含在另一个集合中，则这种子集的大小最大为 ${|S| \choose \left \lfloor |S| / 2 \right \rfloor}$。Sperner 定理的一种推广可以给出本问题的答案：选择满足所有坐标之和等于 $M = \left \lfloor \frac{1}{2} \sum_{i = 1}^{n}{(p_i + 1)} \right \rfloor$ 的位置即可达到最大的数量。

因此，我们需要计算 $\sum_{i = 1}^{n}{x_i} = M$ 的解数，其中 $x_i \in \mathbb{Z}$, $1 \leq x_i \leq p_i$ $(i = 1, 2, \cdots, n)$。考虑容斥原理，可知答案为 $\sum_{I \subseteq J}{(-1)^{|I|}{M - 1 - \sum_{i \in I}{p_i} \choose n - 1}}$，这里 $J = \{1, 2, \cdots, n\}$。注意到这个组合数是关于 $\sum_{i \in I}{p_i}$ 的低次多项式，所以我们可以分别计算 $\left(\sum_{i \in I}{p_i}\right)^e$ $(e = 0, 1, \cdots, n - 1)$ 的贡献。

考虑中途相遇法，我们可以将 $J$ 成 $X = \{1, 2, \cdots, \left \lfloor n / 2 \right \rfloor\}$ 和 $Y = \{\left \lfloor n / 2 \right \rfloor + 1, \left \lfloor n / 2 \right \rfloor + 2, \cdots, n\}$，然后分别预处理关于 $\sum_{i \in X}{p_i}$ 和 $\sum_{i \in Y}{p_i}$ 的信息，最后利用二项式定理和双指针的方法计算它们共同产生的贡献。这样做的时间复杂度是 $\mathcal{O}(2^{n / 2} n^2)$。

# G. Glad You Came

*Shortest judge solution: 1139 bytes. Shortest judge Java solution: 1614 bytes.*

如果有两个操作覆盖相同的区间，我们可以保留最大的那个。对于每个操作 $(l, r, v)$，令 $d$ 等于 $\left \lfloor \log_2(r - l + 1) \right \rfloor$，我们可以用两个操作 $(l, l + 2^d - 1, v)$ 和 $(r - 2^d + 1, r, v)$ 替换此操作。这样做之后，每个操作所覆盖的区间长度均为 $2$ 的幂，这意味着长度仅有 $\mathcal{O}(\log n)$ 种。剩下的只不过是，按长度递减的顺序枚举操作，将每个操作分成两个相等长度的操作，直到区间长度为一。这样做的时间复杂度为 $\mathcal{O}(m + n \log n)$，空间复杂度为 $\mathcal{O}(n \log n)$。

# H. Hills And Valleys

*Shortest judge solution: 1664 bytes.*

枚举 $[x, y]$ 表示翻转区间 $[l, r]$ 中对答案产生贡献的数字所处值域，然后找出 $A$ 最长的类似 $0^* 1^* \cdots x^* y^* (y - 1)^* \cdots x^* y^* (y + 1)^* \cdots 9^*$ 的子序列，其中 $k^*$ 表示任意非负整数个 $k$。

# I. Innocence

*Shortest judge solution: 2851 bytes.*

考虑这个问题的简化版：给定 $N, \{R_i\}, K$，统计有多少种选择 $N$ 个整数 $x_1, x_2, \cdots, x_N$ 的方案满足 $x_i \in [0, R_i]$ $(i = 1, 2, \cdots, N)$ 且它们的按位异或值等于 $K$。考虑数位上的动态规划，我们可以根据最高的出现严格小于的二进制位对所有情况进行分类，这里严格小于是指存在至少一个整数 $x_i$ 在这一位上严格小于 $R_i$。比较麻烦的可能是统计方案数，不过我们已经知道某个整数 $x_j$ 的更低位部分可以取任何数值，因此我们可以先不管它的低位，在确定其他数的低位后再通过方程确定它的低位。

回到原来的问题，我们可以利用容斥原理将其转化为 $2^N$ 个简化版的问题，即用 $x_i \in [0, R]$ 的情况排除掉 $x_i \in [0, L - 1]$ 的情况从而得到答案。对于每个子问题，我们可以用矩阵快速幂加速动态规划的过程，还可以发现 $K$ 对这些问题的影响可以根据满足 $x_i \in [0, R]$ 的情况数量的奇偶性来分类，这意味着我们可以将 $2^N$ 种可能的状态变成 $2$ 类问题，从而优化做法。如果先预处理关于 $N, L, R$ 的动态规划信息再去处理关于 $K$ 的部分，那么每组测试数据的时间复杂度可以做到 $\mathcal{O}((M^3 \log N + Q) \log R)$，这里 $M$ 是指矩阵的边长。顺带一提，标程的 $M$ 是 $8$。

# J. Just So You Know

*Shortest judge solution: 5085 bytes.*

猜测过程实质上构建了一棵决策树，也相当于对 $A$ 的所有子串 $B$ 进行哈夫曼编码。

考虑 $A$ 的后缀树，即所有 $A$ 的后缀（加上一个不存在的字符 \$）组成的字典树，可知树上每个节点到根的路径形成的字符串两两不同，而这样的字符串在 $A$ 中出现的次数等于这个节点的子树里叶子的个数。由于这棵树只会有 $n$ 个叶子，所以这棵树至多有 $(n - 1)$ 次分叉。不妨将只有一个孩子的节点与它的孩子合并，这样整棵树将只剩下 $(2 n - 1)$ 个节点，将会很方便统计有多少子串 $B$ 相应地在 $A$ 中出现了多少次。这个过程可以通过构建后缀数组和构建虚树（即被压缩的后缀树）做到线性复杂度，其中线性时间构建后缀数组可以使用诱导排序。

现在尝试在线性时间内计算构建哈夫曼树的代价，我们需要按照出现次数升序枚举所有可能的 $B$。令 $c_i$ 表示在 $A$ 中出现了 $i$ 次的子串数量 $(i = 1, 2, \cdots, n)$，则有 $\sum_{i = 1}^{n}{i c_i} = \frac{n (n + 1)}{2}$。如果出现次数不超过 $n$，我们可以枚举合并出现次数均为 $i$ 的节点，或是出现次数分别为 $i$ 和 $(i + 1)$ 的节点，然后更新相应的 $c_{2 i}$ 或 $c_{2 i + 1}$。如果出现次数超过 $n$，则这样的节点不会超过 $\frac{n}{2}$ 个，使用一个队列维护这样的节点，每次只需要合并队头的两个节点，向队尾增加新节点，即可做到线性复杂度。

顺带一提，虽然标程的时间复杂度是 $\mathcal{O}(n)$，但是在赛前的测试中，一些时间复杂度 $\mathcal{O}(n \log n)$ 的程序也通过了全部的测试数据。

# K. Kaleidoscope

*Shortest judge solution: 1248 bytes.*

平面展开图是逗你笑的，解决这道题并不需要它。

这是一道 Pólya 定理的经典问题。使用该定理后，我们只需要考虑有多少种方案能给每个轨道选择颜色使得颜色数量满足限制。对于每种情况，若每 $d$ 个面都要选择相同的颜色，我们可以用动态规划计算用前 $i$ 种颜色涂 $j$ 个面并满足颜色数量限制的方案数 $f(i, j)$，并且只考虑 $d | j$ 的情况。事实上，菱形六面体的旋转只有 $60$ 种不同的等价类，它们可以分为 $4$ 类旋转群。时间复杂度可以做到 $\mathcal{O}(4 \cdot 60^2 n)$。

顺带一提，为了最后在模 $p$ 意义下做一次除法，你可以让其他部分在模 $p$ 乘以除数意义下计算，但要注意 $64$ 位整型数可能溢出。

# L. Lost In The Echo

*Shortest judge solution: 5116 bytes.*

这道题目较为复杂，这里将只给出简要做法。需要提醒的是，这不是一道 OEIS 数列题，因为 OEIS 上没有给出这道题的解法；这也不是一道论文题，因为没有论文介绍它，不过感兴趣的同学可以写一篇论文对其进行研究。

考虑只有加减运算符或只有乘除运算符的表达式，例如 $a - b + c$ 和 $a / b * c$。我们可以将其改写为 $0 + a - b + c$ 和 $1 * a / b * c$，因此可知涉及 $n$ 个变量的这类表达式有 $(2^n - 1)$ 种，因为只有 $0 - a - b - c$ 和 $1 / a / b / c$ 这类表达式是无法得到的。

考虑只有加乘除运算符和括号的表达式，例如 $a + b / c$ 和 $a * (b + c)$。我们可以将其划分层次，每一层要么只有加运算符，要么只有乘除运算符，并且相邻两层没有同类运算符，这使得我们可以对其进行统计。考虑由最外层运算符划分的一系列子表达式，我们需要计算每个子表达式的方案数，而这是相似的问题。令 $f(n)$ 表示涉及 $n$ 个变量且最外层为加运算符的表达式数量， $g(n)$ 表示涉及 $n$ 个变量且最外层为乘除运算符的表达式数量。指数型生成函数可以便于我们对带标号的对象进行统计，故定义指数型生成函数 $F(x) = \sum_{n \geq 1}{\frac{f(n) x^n}{n!}}$, $G(x) = \sum_{n \geq 1}{\frac{g(n) x^n}{n!}}$，则有 $F(x) = \sum_{k \geq 2}{\frac{G^k(x)}{k!}}$, $G(x) = \sum_{k \geq 2}{\frac{(2^k - 1) F^k(x)}{k!}}$。在第一个等式中，我们枚举 $k$ 个子表达式的无序组合，在它们之间加上加运算符。在第二个等式中，我们枚举 $k$ 个子表达式的无序组合后有 $(2^k - 1)$ 种方法加上乘除运算符。

不妨定义 $E_F(x) = \sum_{k \geq 2}{\frac{F^k(x)}{n!}}$, $E_{2 F}(x) = \sum_{k \geq 2}{\frac{(2 F(x))^k}{k!}}$, $E_G(x) = \sum_{k \geq 2}{\frac{G^k(x)}{k!}}$，那么有 $F(x) = E_G(x)$, $G(x) = E_{2 F}(x) - E_F(x)$。通过关于 $x$ 求导 $E_F$，我们知道 $E_{F}'(x) = \sum_{k \geq 2}{\frac{F'(x) F^{k - 1}(x)}{(k - 1)!}} = F'(x) \sum_{k \geq 1}{\frac{F^k(x)}{k!}} = F'(x) \left(F(x) + E_{F}(x)\right)$，那么对于 $n \geq 2$ 有 $[x^n]E_F(x) = \frac{1}{n}\left(\sum_{i = 1}^{n - 1}{i [x^i] F(x) \cdot [x^{n - i}]\left(F(x) + E_F(x)\right)}\right)$，这可以通过分治过程配合快速卷积在 $\mathcal{O}(n \log^2 n)$ 时间内计算得出。一些经典的问题给出 $G(x)$ 和 $F'(x) = G'(x) F(x)$ 并需要你计算 $F(x)$，这是不同于本题目的。本题目中待求解的信息同时出现在卷积式两边，需要合理安排分治卷积的过程才能计算，这个留给读者作为练习。

最后考虑有加减乘除运算符和括号的表达式，例如 $a - b / (c - d)$ 和 $a + b / (d - c)$。我们需要注意到分配律所带来的影响，比如上述两个例子是等价的。事实上，除了不包含减运算符的表达式之外，对于任意一个表达式，我们能构造一个与之符号相反的表达式，例如 $a + b + c / (d - e)$ 对应 $c / (e - d) - a - b$。如果我们统计忽略符号的表达式的数量，以及不包含减运算符的表达式的数量，那么就能算出答案。如果忽略符号但是允许使用减运算符，则有 $F(x) = \sum_{k \geq 2}{\frac{2^{k - 1} G^k(x)}{k!}}$, $G(x) = \sum_{k \geq 2}{\frac{(2^k - 1) G^k(x)}{k!}}$。

> Written with [StackEdit](https://stackedit.io/).
